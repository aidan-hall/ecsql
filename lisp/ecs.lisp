(defun ecs-resolve (thing)
  ;; Attempt to resolve `thing' into an Entity or Relation.
  (case (type-of thing)
    ((relation entity) thing)
    ((i32) (ecs-entity thing))
    ((symbol) (ecs-lookup thing))
    ((pair)
     (case (car thing)
       ((rel)
        ;; Relation: (rel Entity1 Entity2)
        (assert (>= (length thing) 3))
        ;; Treat this the same as (Entity1 . Entity2)
        (ecs-resolve (cons (cadr thing) (caddr thing))))
       (t
        ;; Relation: (Entity . Entity)
        (let ((first (ecs-resolve (car thing)))
              (second (ecs-resolve (cdr thing))))
          (if (and (eq (type-of first) 'entity)
                   (eq (type-of second) 'entity))
              (ecs-pair first second)
              (wrong "Failed to resolve list form to Entity or Relation" thing))))))
    (t (wrong "Unable to resolve to an Entity or Relation" thing))))

(defmacro defcomponent (name type)
  `(if (ecs-lookup ',name)
       (wrong "An entity with the given name already exists" ',name)
       (let ((comp (ecs-new-component ',type)))
         ;; Attempt to set the name inside the ECS first, since this could fail.
         (if (ecs-set-name comp ',name)
             (defvar ,name comp)
             (puts "Couldn't set entity name. Cleaning up....")
             ;; Clean up the Entity if we failed to assign the name.
             (ecs-destroy comp)))))

(defcomponent Pos v2)
(defcomponent Vel v2)
(defcomponent Orientation v3)
(defcomponent Health i32)
(defcomponent Mass f32)
(defcomponent Bounce f32)
(defcomponent Radius f32)
(defcomponent Physics nil)
(defcomponent Graphics nil)
(defstruct colour
  (r i32)
  (g i32)
  (b i32)
  (a i32))
(defcomponent Colour colour)

(let ((delta (/ 1.0 120)))
  (defun move-system (e)
    (let ((pos (ecs-get e Pos)) (vel (ecs-get e Vel)))
      (set-v2-x pos (+ (v2-x pos) (* (v2-x vel) delta)))
      (set-v2-y pos (+ (v2-y pos) (* (v2-y vel) delta))))))
