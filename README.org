#+title: ECSQL
#+author: Aidan Hall
#+todo: TODO DOING(!) | DONE(@) CANCELLED(@)
* Introduction
This is the source code for ECSQL.
#+begin_src emacs-lisp
(inferior-lisp (file-truename "./ecsql"))
#+end_src
* Tasks
:PROPERTIES:
:COLUMNS:  %ITEM %PRIORITY %TODO
:END:
Since we must rely on some piece of software for project management,
we will use the most reliable one (in terms of longevity): Emacs.
** Design
*** TODO Basic ECS Architecture [3/4]
**** DONE Automatically generated Entity IDs
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-02-05 Mon 14:51]
- State "DOING"      from "TODO"       [2024-02-05 Mon 14:51]
:END:
- Simple generational ID system.
- Hash IDs to get indices so we don't have to aggressively collect
  them like in Tecs.
**** DONE Component "Ownership"
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-02-14 Wed 17:15] \\
  Basically copied Mertens's blog post; this isn't an area of focus for
  the project.
:END:
- What components does an Entity have?
  - Array of Component IDs per archetype(?)
  - Something like Flecs: Each Component has a hash set of the
    archetypes that contain it, and provide an efficient facility to
    identify an Entity's archetype.
- API for +/-?
- Don't conflate data layout and Component type: Many Components may
  be a single number or vector, and it should be possible to treat
  them as such.
**** DONE Component Storage
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-02-14 Wed 17:16] \\
  We currently have a single dynamically allocated vector per Column,
  rather than chunks as originally planned. Making the switch would be
  moderately hard, and unlikely to have any apparent effect on
  performance, so we probably won't bother.
- State "DOING"      from "TODO"       [2024-02-05 Mon 14:52]
:END:
- Archetype tables: Entity=row, Component data=column.
**** DOING System Scheduler
:LOGBOOK:
- State "DOING"      from "TODO"       [2024-02-05 Mon 15:14]
:END:
- Fairly tangential to the premise of ECSQL, so either:
  - Manual :: User code to specify the order of execution.
  - Ordering Relation Tree :: As in Flecs.
  - Order of creation :: Fine for non-rendering Systems.
*** TODO ECSQL Language Specification [0/11]
- [ ] Create and delete entities
- [ ] Add and remove Components
- [ ] Display and edit Component data
- [ ] Entity/Component selection with Queries, based on the Entity relationships in the ECS design.
- [ ] Start and stop systems
- [ ] List running systems
- [ ] Component data transformation, via calls to Systems and functions
- [ ] System composition, and definition of new systems based on these compositions
- [ ] FFI to Systems written in host language
- [ ] Deferred event queue
- [ ] BNF grammar
*** DOING Many Languages
:LOGBOOK:
- State "DOING"      from "TODO"       [2024-01-15 Mon 11:06]
:END:
If ECSQL is implemented with heavy use of macros, a relatively small
amount of additional work would be necessary to also implement more
languages that may work with ECS.  Our ideas are as follows:
**** Story/Dialog System
Conversation trees could be implemented quite naturally as a Lisp DSL,
containing arbitrary calls to Lisp code for conditions like "has
the player got the macguffin?".
**** Text Markup
Allow arbitrary tree structure for pieces of text, with basic bold and
italic markup.  E.g:
#+begin_src lisp-data
("This is something I" (_ "have") "to see.")
(say npc-jeff
 (if (has player macguffin)
     "My macguffin! Please return it."
   "I need someone to find my macguffin..."))
#+end_src
This snippet includes a check using the ~has~ predicate, which could
be generated by ECSQL based on a relationship with the same name.
**** Scene Tree
Inspired by Flecs, it would be convenient to represent the entire
state of a game as list structure, especially for (de-)serialisation.
**** Graph/Data Flow Language
On [[https://ajmmertens.medium.com/ecs-from-tool-to-paradigm-350587cdf216][Mertens' wish list]]; probably easy to represent a graph structure as
Lisp data, could help to justify extreme slowness, quite novel.
*** DONE Lisp Compiler Target
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-26 Fri 15:36] \\
  Just do the naive interpreter, unless we are /done/ done, with
  everything else, very early.
- State "DOING"      from "TODO"       [2024-01-26 Fri 15:36]
:END:
Options:
**** Naive Interpreter
Potentially useful for testing and bootstrapping purposes.
**** LLVM IR
| Advantages   | Disadvantages                     |
|--------------+-----------------------------------|
| Native speed | Complex C++ API, incomplete C API |
| Intrinsics   | A large, heavy dependency         |
| Familiarity  | Not for the C API                 |
| Phi nodes    |                                   |
**** Own bytecode
| Advantages         | Disadvantages               |
|--------------------+-----------------------------|
| Fewer dependencies | Slower                      |
|                    | Lots of irrelevant problems |
**** LibGCCJIT
| Advantages                    | Disadvantages         |
|-------------------------------+-----------------------|
| Ganoooo!1!                    | Unfamiliar            |
| Very simple(?)                | No Phi nodes          |
| Similar to LLVM               | Limited documentation |
| C is primary API              |                       |
| Primarily intended for JIT(?) |                       |
The lack of Phi nodes is notable because they fuse the results of
branches /in an expression/.  We may be able to hack them on top of
the conditional and switch instructions.
*** DONE Compiler Architecture
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-26 Fri 15:36] \\
  Evaluator.  See [[*Lisp Compiler Target]].
- State "DOING"      from "TODO"       [2024-01-26 Fri 15:36]
:END:
1. Reader (lex + parse): Output is already Lisp data!
2. Lisp â†’ Stack Machine:
   #+begin_src lisp-data
     (label
      (push 5)
      (push 4)
      (call + )
      (return))
   #+end_src
   - As in Queinnec.  Probably the most complex part, and it can be
     totally backend-independent!
   - Stack machine has a limited, but non-trivial instruction set that
     should easily map to libgccjit or LLVM IR, notably including
     (variadic) function calls.
   - CFG form(?)
   - Maximum stack depth in each function is known statically (deepest
     expression nesting level).
3. Evaluator: libgccjit or simple interpreter.
*** DOING Demo Application
:LOGBOOK:
- State "DOING"      from "TODO"       [2024-02-20 Tue 10:39]
:END:
- 2D Raylib game
*** TODO Asynchronous REPL
:LOGBOOK:
CLOCK: [2024-02-20 Tue 11:28]--[2024-02-20 Tue 11:53] =>  0:25
CLOCK: [2024-02-20 Tue 10:57]--[2024-02-20 Tue 11:22] =>  0:25
:END:
We want the game to progress and have the REPL available
simultaneously, without blocking either.

Problems:
- Lexer uses a global, static buffer for reading in lexemes, which is
  not thread-safe (easy).
- Lisp memory allocation (medium).
- Namespace/environment access etc (hard-ish: what is "etc"?).
- ECS, in general, is not thread-safe.

Goal:
- Main game loop is mostly normal, running a set of Systems and
  refreshing the screen each frame.
  - Can call into Lisp(?), perhaps only via a special Lisp callback
    System.
- REPL available simultaneously. Once a complete sexp is read, the
  input Lisp form is evaluated, perhaps on the next frame, and
  the result is printed out.

Options:
- [ ] Single threaded with non-blocking I/O.
  - Use non-blocking stdio for the reader (unlocked_stdio(3)), and
    dispatch to Lisp as soon as a complete sexp is read.
  - Relies on non-standard (POSIX) functions
  - Potentially unpredictable
  - Complex to structure(?) since we need to repeatedly call the
    reader polling function.
- [ ] Basic locking: Allow simultaneous threads, but acquire a
  lock to allocate memory, add to a namespace etc.
  - Extreme false dependencies and high contention, since current Lisp
    implementation conses continously to evaluate code, leading to
    slower, serial execution regardless.
  - Hard to be sure all thread-unsafe operations are locked properly.
  - Could be viable if we replace the evaluator with a bytecode VM
    that conses less during execution, but we don't have time for that
    now (<2024-02-20 Tue>).
- [ ] Lisp command event queue (cite:
  http://gameprogrammingpatterns.com/event-queue.html)
  - Game code and REPL send Lisp expressions to the event queue to
    evaluate, with a single thread receiving events and executing
    them.
  - Problematic since generating expressions (e.g. while parsing)
    requires consing, so we may need locked cons.
  - Callers often want the result of the expression, so they would
    need to block until their expression was evaluated.
- [X] Global Lisp lock: Public expression evaluation API acquires a
  lock stored in the LispEnv for the duration of evaluation, then
  releases it.
  - Could greatly increase complexity of existing code if all public
    APIs must include locking.
  - A fixed, finite number of places where locking happens (Lisp System
    wrapper System, REPL) makes this feasible.
  - REPL must be written in C.
- [ ] Pause the game to run the REPL, or any Lisp code (giving up):
  - Possibly suitable if I spin it right.
  - Main viable option for evaluation day (<2024-02-21 Wed>).
*** CANCELLED "Safe" Component +/- in Systems
:LOGBOOK:
- State "CANCELLED"  from "DOING"      [2024-02-20 Tue 23:23] \\
  Definitely a distraction
- State "DOING"      from "TODO"       [2024-02-20 Tue 23:19]
:END:
- Deferred change queue
- Due to the way (cached) queries work, we can probably /add/ an
  Entity to an archetype immediately, and put the new Component data
  in the storage allocated for it there.
- Removals are what could lead to "dangling" references, so we can get
  mostly correct behaviour by immediately updating everything so the
  Entity "is in" the new Archetype, but not removing it from the old
  archetype until, for example, the System finished executing.
*** DONE Automated Join/Outer Product/N-wise operations
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-02-28 Wed 16:29] \\
  Implemented sufficiently in ~run_matching_self_join_systems~, and
  associated Components.
- State "DOING"      from "TODO"       [2024-02-28 Wed 16:29]
:END:
- Classic example: Collisions
- Easier if user code is restricted to a specific pair of Entities,
  but that comes at the cost of efficiency.
- Current implementation uses plain indexable arrays for the
  iterators, but it /may/ be possible to manipulate these to handle
  pairs properly.
- *The "hard" problem*: Iterating distinct pairs of Entities (i.e.
  (a, b) and (b, a) should not both occur, and perhaps no (a, a)).
- Doing an outer product on two distinct archetypes is easy: just pass
  2 iterators to the user code, and all pairs are distinct.
  - This is the common case, even when joining a query on itself (as in collisions).
- Can and should this be generalised to N-way outer products?
  - I've only had the occasional need for pairwise operations.
    Operations on 3 or more Entities at once may either be represented
    as pairwise interactions between all Entities involved, or involve
    another mechanism to get at all the Entities in a sensible way.
  - Probably not.
** Implementation
*** DONE Lisp Interpreter [14/14]
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-02-05 Mon 11:04] \\
  We have now implemented a sufficient interpreter to do some
  higher-level ECS stuff with macros, though that depends on having the
  ECS itself, so the primary Lisp implementation is done.
- State "DOING"      from "TODO"       [2024-02-05 Mon 11:04]
:END:
**** DONE Lexer
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-11 Thu 18:11] \\
  - Decided against active UTF-8 support, but it would probably work.
  - Treat ~@~ as a stand-alone Token. The parser can easily "look ahead"
    when it gets a ~,~ to see if it should be a normal or splicing
    unquote.
CLOCK: [2024-01-11 Thu 18:04]--[2024-01-11 Thu 18:11] =>  0:07
CLOCK: [2024-01-11 Thu 14:50]--[2024-01-11 Thu 18:04] =>  3:14
- State "DOING"      from "TODO"       [2024-01-11 Thu 14:49]
:END:
- [X] Token type
- [ ] +UTF-8+
This either needs to operate on a string buffer in memory, or a
~FILE*~.  There are platform-dependent ways to access a string buffer
as a ~FILE*~, and many platform-independent operators for ~FILE*~'s,
so we will use ~FILE*~.
**** DONE Lisp Object Physical Representation
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-15 Mon 10:26] \\
  We found a reasonable compromise representation.
CLOCK: [2024-01-12 Fri 15:11]--[2024-01-12 Fri 19:26] =>  4:15
CLOCK: [2024-01-11 Thu 18:19]--[2024-01-11 Thu 18:22] =>  0:03
- State "DOING"      from "TODO"       [2024-01-11 Thu 18:18]
:END:
- For this, consider 64-bit integer boxing.
- Notable: There are 12 unused bits in Mertens's Entity
  representation, and we can probably shave off a few bits from the
  generation and Entity, so this could fit inside a NaN box!
- Queinnec: p. 391, tinylisp: p. 7-9

I need a representation for Lisp objects that is simple enough to
manipulate inline with generated LLIR, and reasonably efficient.

***** Constraints/Requirements
- Must represent the following:
  - Standard Lisp types:
  - Vectors (ideally):
  - Entity IDs and relations (require c. 50b):
  - User-defined structs: Pointer to storage, getters, setters;
    Use the ~getelementptr~ LLIR instruction.
  - Archetypes:
  The question is how many of these must be hard-coded into the object
  representation.  If a fundamental structure like Entity IDs can fit
  into an object inline, that allows some decent optimisation of how
  generated code can handle them.
- 64 bits: Biggest easily moveable size.
***** NaN Boxing
- tinylisp/van Engelen
- 51 bits for non-float values
***** Pointer/Int Boxing
- Queinnec, p. 390.
- LSB 1 â†’ integer in upper 63 bits
- LSB 0 â†’ pointer to object union.
- The pointer value is aligned, since the pointee is a large object,
  so 2+ LSBs are 0. The rest of the LSBs can store type info.
- Pointers can be used as-is, but getting the type for non-integers
  requires a separate memory read.  Given the cost of memory access is
  orders of magnitude greater than individual instructions, we should
  include all such metadata in the immediate value, even if it is more
  work to extract.
***** Considerations for my version
- If we need even fewer than 63 bits, we can store more than just
  integers inline.
- If addresses are indices into the Lisp memory pool (useful for
  relocation, etc.), 32- or maybe 48-bit integers would be sufficient,
  and we don't rely on pointer alignment, so the exact position of the
  bits is of less concern.
- The type recognition scheme needs to be simple and non-branching,
  since it will need to run almost continuously.
- 5 bits for Lisp type tag, to ensure we don't run out.
- Definition: An immediate value contains its data, as opposed to an
  indirect value.  The NaN-boxed address in Lisp memory is the
  representation for indirect values.

Discussion: Do the Entity ID types need to be explicitly in the types?
- If they are immediate, Lisp code can manipulate their contents
  highly efficiently.
- This could be achieved equally well by storing them in the integer
  type, right?
- Making them first-class was a primary justification for me building
  my own Lisp at all.
- With them built-in, we gain some protection from user input, since
  they can't so easily supply a garbage integer value: Entity IDs can
  only be generated by the system itself.
- Cost of "blessing" them: Complexity?
- Poor unity of purpose having 5 possible immediate meanings?
***** NaN-Boxed
#+begin_example
+-------------------------------+-----------------------------++
<-------------------- Double  (62b)----------------------------> Value is a valid double as-is!
s111111111111<--------Arbitrary Data Goes Here (46b)------><typ> QNaN boxed. Type
s111111111111<-------Entity (27b)------><---Gen (16b)--><-><typ> Type Flags (c. 3b)
s111111111111<--Comp/Rel T ------(27b)-><-- Rel  (16b)-><-><typ>

Undesirable:
<---------------Integer (63b)--------------------------------->1
#+end_example
***** Non-NaN-Boxed
NaN-boxing incurs an excessive overhead, which especially hurts the
Entity ID representation due to Mertens, which is already squeezed
tightly into 64 bits, especially for relation pairs.  A 5-bit Lisp
object type tag should be sufficient to represent all fundamental
types in the language, while leaving plenty of space for immediate
values.
#+begin_example
+-------------------------------+-----------------------------++
<----------------------Data (59b)-------------------------><typ>
<-------Entity (32b)-----------><---Gen (16b)-->0000000<*-><typ> *Entity type flags (4b)
<--Comp/Rel T ------(32b)------><---Relation (23b)----><--><typ>
<----------------------Integer (59b)----------------------><typ>
<----------------------"Double" (64b)---------------------><typ>
<-----------Index   (43b)-----------------><-Metadata(16b)><typ>
#+end_example
Our double type could be handled specially: the 5 type bits align with
the LSBs of a double's mantissa.  To get the represented value, we
will mask out the type bits instead of shifting.  This allows us to
represent the full range of doubles, with only a moderate loss of
precision.  In reality, it will be easier to just box a 32-bit float
normally, since these are the standard in games anyway.

We only have 23 bits for Entity relationships, but this still allows
8,388,608 different relationships to be represented, which should be
plenty.

A lot of object values will contain a "pointer" to Lisp data (more
likely an index), which may need to be accompanied by some metadata.
The pointer size places an upper bound on how large Lisp memory can be
(including the overhead of uncollected garbage), so we allocate an
excessive 43 bits to it.  The metadata will often be the length of a
slice type (e.g. for arrays), which may not necessarily be in units of
Lisp cells (e.g. for strings).

Pointer+length objects are called fat pointers, and provide numerous
benefits such as creating slices of arrays without having to move the
data.

Strings and symbols should probably be handled differently to keep
things efficient.

The bare essential built-in types are:
- [X] Integer
- [X] Double
- [X] String
- [X] Symbol
- [X] Pair
- [X] Primitive function
- [X] Closure (lambda)
- [ ] Compiled Closure(?)
- [X] Fixed-length vectors(?)
- [ ] Struct

We initially used a simple ~typedef~ for the Lisp object type, but
this was error prone, since C was allowing implicit conversions
between integers and Objects, which were invalid.  We replaced this
with a complex union with bit fields, immediately revealed a large
number of such invalid conversions (<2024-02-08 Thu>).
**** DONE Scope, Namespaces etc.
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-26 Fri 12:13] \\
  - We have created a trivial implementation of Lisp-3 (variables,
    functions, macros), with lexical scope for variables and only global
    scope for functions and macros.
  - Macros are implemented simply as closures.
- State "DOING"      from "TODO"       [2024-01-22 Mon 10:31]
:END:
- Lexical
- Lisp-1?
  - Lisp-1 is more conceptually elegant, but Lisp-2 may be easier/more
    efficient to compile.
- There's a question of how to implement scopes.  If they aren't
  needed at run-time, it may be acceptable to use a naive alist
  structure.
- Conceptually pure approach: Only implement local/lexical binding
  through lambda parameter lists, though this requires either Lisp-1
  or the "special case" first-position ~lambda~ of Common Lisp.
- Variable-length argument lists are a similar consideration: An
  actual Lisp list in the "AST" can easily be converted to a
  variable-length argument pack in libgccjit.  On the other hand, in
  real Lisps, variable argument lists are treated as actual lists by
  the callee too, so the obvious solution /may/ be sufficient.
  - Solution: Put /all/ the arguments into a list, and for
    variable-length argument lists, make the "rest" parameter the
    ~cdr~ past a certain point.
**** DONE Memory Allocation
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-22 Mon 10:31] \\
  Garbage collection is actually quite low-priority, so we can defer it
  until we know we have time for it.
- State "DOING"      from "TODO"       [2024-01-22 Mon 10:31]
:END:
- Allocate in increments of 64-bit cells?
- The /directly referenced/ values of global variables can be placed
  in a "static" data store, though this is a small optimisation.
**** CANCELLED Copying GC
:LOGBOOK:
- State "CANCELLED"  from "TODO"       [2024-01-26 Fri 15:37] \\
  Leaking into a 1GB+ buffer is fine, since GC isn't relevant to the
  project concept.
:END:

**** DONE Pure C Parser
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-22 Mon 10:35] \\
  Actually implemented reader macro support with function pointers.  It
  should be possible to write new ones as compiled functions.
- State "DOING"      from "TODO"       [2024-01-22 Mon 10:34]
:END:
- [X] List structure
- [X] Literals
- [X] ~'~, ~`~, ~,~, ~?~
- [ ] ~,@~: Requires more context, and quite niche: won't do.
**** DONE [#C] Parser with Macros
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-22 Mon 10:37] \\
  See [[*Pure C Parser]].
- State "DOING"      from "TODO"       [2024-01-22 Mon 10:37]
:END:
Macros are a productivity multiplier that may prove necessary in order
to complete the project on time.
**** CANCELLED [#B] Splicing Unquote
:LOGBOOK:
- State "CANCELLED"  from "TODO"       [2024-01-26 Fri 12:10] \\
  We can use the dot operator to get most of the benefit of this with no
  extra work:
  - ~`(some things are so . ,(or 'cool 'lame))~
  - ~(some things are so cool)~
:END:
- This feature is essential for the ergonomics of a macro system.
- If not implemented "properly" as a reader macro, it would be easy
  enough to hard-code it into a pure C reader.
***** DONE [#C] Read Macros
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-22 Mon 10:38] \\
  See [[*Pure C Parser]].
- State "DOING"      from "TODO"       [2024-01-22 Mon 10:38]
:END:
**** CANCELLED Code Generation
:LOGBOOK:
- State "CANCELLED"  from "TODO"       [2024-01-26 Fri 15:38] \\
  Not doing a compiler.
:END:

**** CANCELLED [#C] Optimisations
:LOGBOOK:
- State "CANCELLED"  from "TODO"       [2024-01-26 Fri 15:38] \\
  We don't care about performance.
:END:
- Just turn on the feature in the code generator.
**** DONE REPL
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-26 Fri 12:06] \\
  Could be implemented in Lisp instead of C, but this periodic movement
  of control back out of Lisp is a good opportunity to perform garbage
  collection since the Lisp stack is empty at that point, so we only
  need to use global variables as roots.
- State "DOING"      from "TODO"       [2024-01-22 Mon 10:32]
:END:
Basically necessary to the way Lisp should function, including macros.
- [X] Read
- [X] Eval
- [X] Print: This will need extension every time we add a fundamental
  type, but
- [X] Loop
**** DONE Error Handling
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-26 Fri 12:05] \\
  Simplistic error message + longjmp is quite sufficient.
- State "DOING"      from "TODO"       [2024-01-22 Mon 10:59]
:END:
Ideally this should be entirely handled by the ~wrong~ function.
Options:
#+attr_org: :radio t
- [ ] Invalid type/error object (de facto approach)
- [X] setjmp/longjump
**** CANCELLED [#C] LValues
:LOGBOOK:
- State "CANCELLED"  from "TODO"       [2024-02-05 Mon 11:02] \\
  This would introduce a very un-Lispy complication to the
  implementation.
:END:
- ~(setf place value)~: ~place~ must be an lvalue.
- In C/libgccjit, lvalues are a subkind of rvalues (normal values).
- Issues:
  - Can't have references to globals, outside Lisp memory.
  - Potential efficiency cost, especially for struct accessors.
**** DONE Struct Types
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-02-14 Wed 17:11] \\
  Lisp can now generate struct types that should have the same alignment
  and padding as equivalent C structs (same member types, in the same
  order).
- State "DOING"      from "TODO"       [2024-02-12 Mon 15:54] \\
  We need to amend this slightly so we can work with packed, C-style
  struct data.
- State "DONE"       from "DOING"      [2024-02-05 Mon 11:02] \\
  Implemented in Lisp as far as possible (only using C to manipulate
  internal representations), with simple 1-cell alignment/size for all
  primitive types.
- State "DOING"      from "TODO"       [2024-02-05 Mon 11:02]
:END:
- Use libgccjit's structs for reflection etc.
Requirements:
- [ ] Getters
- [ ] *Setters*: Do we attempt "generalised variables"? No.
- [ ] Field types: All fundamental types, or struct types(?).
Lisp Representation:
- Storage :: Vector, each member (which *must* be of the provided
  typespec, checked by ~lisp_type_spec_matches~) in a cell.
- Name :: Symbol, bound in the function namespace as a constructor(?).
- Definition :: As below:
  #+begin_src lisp
(defstruct v3f
  (x f32)
  (y f32)
  (z f32))
(defstruct physics
  (pos v3f) ; Recursive structs
  (vel v3f))
(defstruct node
  (car t)
  (cdr t))
  #+end_src
- API :: As below:
  #+begin_src lisp
(node-car (make-node 'a 'b)) ; a
(set-v3f-x v (+ 1 (v3f-x v)))
(set-physics-pos-x player (+ 1 (physics-pos-x player)))
(set-physics-vel player (make-vector 2 2 2))
  #+end_src
- Single Inheritance :: Possibly useful idea: Same members and
  interface as another struct, but considered a distinct type by Lisp.
  - Could be as simple as physically splicing in the struct member
    list from the parent class and dispatching to normal ~defstruct~.
  - Include a cast to the base class.
  - Not in the spirit of, or relevant to, what we are doing.
*** TODO ECS [3/7]
**** DONE Entity IDs
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-02-09 Fri 12:45] \\
  23-bit unsigned integers.
- State "DOING"      from "TODO"       [2024-02-06 Tue 14:07]
:END:

**** DONE Component Store
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-02-09 Fri 12:52] \\
  As explained by Mertens, the implementation is the same with or
  without relations.
- State "DOING"      from "TODO"       [2024-02-06 Tue 14:07]
:END:
***** Lookup Archetype by Component List
- In Mertens's blog post, which introduces a basic archetype-based
  Component store, he uses C++ stdlib sets and maps, which support
  hashing stdlib data structures, notably including hashing arrays of
  Components to access the correct Archetype.  We have been using
  khash for sets and maps, and it only supports hashing integers and
  null-terminated strings.
- Mertens explains that array hashing is too slow for operations like
  adding or removing one Component in a hot loop: when is the
  ~Component[]~ â†’ ~Archetype~ map actually useful?
- Extend khash to support hashing arrays?  This sounds like a
  disappointingly brute-force solution.
- Naively store Archetypes in an array and search for them?  This
  could yield O(n^2) lookup to find the Archetype for a particular
  Component set, if implemented poorly.
  - This "direct" access is exceptional anyway, so don't worry about
    it being slow!
- One solution could be to limit Component IDs to [1, 255] and
  actually store them in null-terminated strings, but we want to
  implement relationships, and Entities as Components, so we need
  32-bit Component IDs (since they are equivalent to Entity IDs).
- Traverse the Archetype graph by "adding" 1 Component at a time?
  - Doesn't require direct access to the Component list.
  - Requires a path from the empty Archetype to every other, wasting
    memory for the many unused Archetypes.
  - Effectively O(n) /linked list/ traversal, vs O(n) array hashing.
    This could be amortized if Archetype references are reused for
    creating many Entities.
  - This needs to be built initially, however.
***** CANCELLED Columns and Alignment
:LOGBOOK:
- State "CANCELLED"  from "TODO"       [2024-02-09 Fri 12:51] \\
  C automatically pads structs to ensure alignment, so we must solve any
  problems with alignment in struct.lisp.
:END:
- Columns store Component data in packed byte vectors, so it's
  possible we could have alignment problems.  A solution would be to
  add an alignment parameter for registering Component data blocks.
***** Bootstrapping Process
- It's a nice idea to use a "Component Storage" Component to store the alignment and size of a Component, but it makes the initial setup a little awkward, since we need to add it to itself.
- Our solution is as follows:
  1. Create the "Component Storage" Component/Entity (it will go into the empty archetype),
  2. Create the Archetype for Entities with only the "Component Storage" Component, manually specifying the storage parameters in its only Column (which contains the Component Storage data),
  3. Add "Component Storage" to itself, with the appropriate data values.
  4. For all Subsequent Components with storage, simply add the "Component Storage" Component and it will just workâ„¢.
**** DOING Queries
:LOGBOOK:
CLOCK: [2024-02-20 Tue 12:09]--[2024-02-20 Tue 12:34] =>  0:25
- State "DOING"      from "TODO"       [2024-02-15 Thu 10:42]
:END:
The general API needs to be something like: ~Predicate â†’ Archetype[]~
***** DONE Archetype Iteration Mechanism
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-02-20 Tue 12:10]
- State "DOING"      from "TODO"       [2024-02-20 Tue 12:10]
:END:
We need to be able to efficiently iterate over all the Entities in an
Archetype.
***** DONE Query Representation
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-02-20 Tue 22:42] \\
  See [[*Query Result Representation]]
- State "DOING"      from "TODO"       [2024-02-15 Thu 10:42]
:END:
- Queries may reasonably take the form of Lisp list structure.
- The syntax of Queries is partially defined in design.org in the
  cs310-project repository.
***** DONE Query Result Representation
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-02-20 Tue 22:42] \\
  Straightforwardish, kept abstract to make future changes easy.
CLOCK: [2024-02-16 Fri 15:57]--[2024-02-16 Fri 16:57] =>  1:00
- State "DOING"      from "TODO"       [2024-02-16 Fri 15:57]
:END:
- This informs the capabilities of the query system.
- Generality vs Efficiency?
- How do results and generated Lisp code (with bindings) match up?
Single-archetype queries:
#+begin_src c
struct QueryEntry {
  ArchetypeID archetype;
  /* What column each matched Component with storage is in.
   ,* The alternative is doing a lookup per Component per Archetype,
   ,* which could be alright if fragmentation is low. */
  size columns[];
};
#+end_src
Multiple-archetype Queries:
#+begin_src c
struct QueryEntry {
  ArchetypeID archetypes[];
  /* The Lisp macro or C system author should statically know what archetype to
   * use for each column index lookup. */
  size columns[];
};
#+end_src
***** TODO Lisp Interface
**** TODO Systems
- Iteration over Archetypes:
  1. User supplies a function to the ECS.
  2. The ECS calls that function once for each matched (set of) Archetype(s)
**** DOING [#C] Relationships
:LOGBOOK:
- State "DOING"      from "TODO"       [2024-02-09 Fri 19:19]
:END:
- Is this essential?
- What is the simplest form of relationships I could implement?
***** Mertens' Roadmap, Culled
https://ajmmertens.medium.com/a-roadmap-to-entity-relationships-5b1d11ebb4eb

Mertens describes the first 5 steps as sufficient to produce a
rudimentary implementation of relationships, with an estimated time to
implement of 16 weeks.
1. [X] Components as entities
2. [ ] Observers
3. [X] Relationship pairs in archetype storage
4. [ ] Relationship component data storage: Flecs makes this highly
   complex with a sequence of rules that are tried.  We can probably
   find a "worse" compromise set of rules, or exclude this feature
   altogether.  Example compromise rules:
   1. Never create storage for the first element.
   2. Create the storage for the second element iff it's a non-tag
      type:
      - ~e.add(apples, eats, {2})~
      - ~e.add(parent, childOf)~
   Or:
   1. Include a tag bit in the pair representation.
   2. Associate with type of first element, iff tag bit is 0.
   This might not work, since that tag bit isn't representable
   in the Query DSL syntax:
   - ~(child-of parent)~,
   - ~((eats 2) apples)~
   In any case, we can simply add any data we want to one of the
   entities in the relationship.
5. [X] Wildcard queries: Looks impressive, and Mertens doesn't even
   consider it especially hard, at "merely" 2 weeks.
6. [X] Component index
7. [ ] Cleanup: Important, but we must find a simplified approach if
   we are to consider implementing it.
8. [ ] Cleanup Traits
9. [ ] Multi-source queries
10. [ ] Relationship traversal
11. [ ] Query cache revalidation
12. [ ] Breadth first traversal
13. [ ] Uncached queries
14. [ ] Multi component observers
15. [ ] Event propagation
16. [ ] Empty table optimisation
17. [ ] Garbage collection
18. [ ] Rule engine
19. [ ] Exclusive relationships
20. [ ] Inheritance
21. [X] Query DSL
***** My Approach
- For starters, relationship components seem like a mostly unnecessary
  feature.
- How much could we hand off to a working Lisp implementation?
  - Notably, garbage collection?!
- Value trade-off of allowing an Entity to have the same relation to
  two distinct Entities?
  - Better to allow it.
**** DOING [#A] Lisp API
:LOGBOOK:
- State "DOING"      from "TODO"       [2024-02-14 Wed 17:13] \\
  Current implementation:
  ~(set-v3-x (ecs-get player Velocity) 3)~
:END:
- We should provide a flexible API, so new features/applications can
  be built entirely in Lisp.
- Is a Lisp callback API ("for each Entity") sensible? Does a
  facsimile crafted with macros make more sense?
- Need to find a good way to make it terse: Lisp code interfacing with
  strong types can quickly become annoying to read and write:
  - Bad:
    ~(set-x (get-vec (get-velocity entity)) 3)~
  - Better:
    ~(setf (x (velocity entity)) 3)~
  - Better still:
    ~(setf (x velocity) 3)~, with velocity bound as an "lvalue" with
    macro/codegen sorcery.
  - ~(setf velocity [3 0 0])~
- Trying to produce a nice API like one would have in C may be the
  wrong approach: Allow the C plumbing API to be awful, and build nice
  ones on top of that?
***** DONE Accessing ECS Data from Lisp
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-02-14 Wed 17:14] \\
  We chose option 1, since it was so simple to implement. Since the
  implementation exists just in the definition of Object and
  lisp_cell_at, we can easily change it later if necessary.
- State "DOING"      from "TODO"       [2024-02-14 Wed 17:14]
:END:
- The first, most basic problem is that ECS data isn't stored in, or
  aligned to, Lisp memory.
- Can't store Columns in Lisp memory since GC they need fairly
  frequent, large allocations, which wouldn't be friendly to our
  "garbage collection strategy".
Options:
1. Store pointers in Lisp memory and use double indirection
   - Inefficient(?), but easy to implement.
     - Possibly not so inefficient if we're iterating over arrays?
   - Need to keep track of the type.
   - Implicit assumption that structs are at least 64-bit aligned?
     - Hopefully not necessary (appeal of double indirection)
   - Can't store raw pointers for "a long time", since Columns (and
     Archetypes) may get reallocated.
   - Possible implementations:
     - Add a flag bit to index boxes that
       indicates extra indirection, or a small number (2-4 bits) to
       indicate the number of times to indirect?
     - Negative indices indicate 1 level of indirection.
       - Breaks the assumption that we can simply add to an index to
         get an index for data at that offset, "for free", but that
         was probably incorrectly API use to begin with.  It was a
         mechanical fix to handle these cases properly.
2. Store Columns next to Lisp memory, and just use indices that reach
   out to them.
   - Error prone, and won't work with data at less than 64
     bits of alignment.
3. Support LValues
4. Custom addressing mode (not based on boxed indices) for Entities.
   - E.g. boxed tuple: (ArchetypeID, Column, Row, Offset/B)
     - Tight squeeze
     - 16 + 16 + 16
   - Greater complexity, and creates a hard distinction between
     structs inside and outside Lisp memory.
**** DONE Structs and Components
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-02-19 Mon 14:33] \\
  Just used existing Lisp struct reflection mechanism.
- State "DOING"      from "TODO"       [2024-02-07 Wed 17:38]
:END:
- It should be possible to implement Lisp structs in such a way that
  they blend with the ECS.  [[https://ajmmertens.medium.com/doing-a-lot-with-a-little-ecs-identifiers-25a72bd2647][Mertens proposes an approach to this.]]
- Struct metadata relation:
  - Name (symbol?) & type per struct member.
    This would be the maximally ECS'd option.
  - Reference to an entry in my existing Lisp struct metadata table.
    This may require less work, but isn't as conceptually elegant.
***** Struct/Component Reflection Data in the ECS
As described by Mertens, have a "Struct" Component that contains
reflection data.  Adding it to a Component Entity associates that
reflection data with the data stored for that Component type.

Reflection data includes:
- Size of the whole Component,
- Alignment of the whole Component,
- Information about sub-structure.

The ECS itself only needs the size and alignment for manipulating
Component data: it just works with bytes and pointers.
The information about sub-structure is only needed in Lisp.
Sub-structure means the set of struct members, and the following
information about each:
- Offset from the start of the struct,
- Type: A Component, with its own Reflection data Component(s)
  - Size,
  - Alignment,
  - Name,


A bar to hit for supporting general and useful structures could be to
support structs that contain structs.  Alternatively, we could rigidly
require that a struct only contains primitive types, and use separate
Components to group them together.  That would probably be
unnecessarily restrictive, and there are many plausible Components
such as "Transform" that would contain multiple vectors/matrices for
position and orientation.

* Development Notes
** Recurring Bugs
*** Junk in unused bits of ~Object~
- For consistency, unused bits of an Object should be zeroed.
- This ensures that two Objects that store the same value are
  bit-for-bit identical, so we can use the cheap C ~==~ operator to
  implement ~(eq)~ in Lisp.
