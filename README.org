#+title: ECSQL
#+author: Aidan Hall
#+todo: TODO DOING(!) DONE(@)
* Introduction
This is the source code for ECSQL.
* Tasks
:PROPERTIES:
:COLUMNS:  %ITEM %PRIORITY %TODO
:END:
`Since we must rely on some piece of software for project management,
we will use the most reliable one (in terms of longevity): Emacs.
** Design
*** TODO Basic ECS Architecture [0/3]
**** TODO Automatically generated Entity IDs
**** TODO Component Store
**** TODO System Scheduler
*** TODO ECSQL Language Specification [0/11]
- [ ] Create and delete entities
- [ ] Add and remove Components
- [ ] Display and edit Component data
- [ ] Entity/Component selection with Queries, based on the Entity relationships in the ECS design.
- [ ] Start and stop systems
- [ ] List running systems
- [ ] Component data transformation, via calls to Systems and functions
- [ ] System composition, and definition of new systems based on these compositions
- [ ] FFI to Systems written in host language
- [ ] Deferred event queue
- [ ] BNF grammar
*** DOING Many Languages
:LOGBOOK:
- State "DOING"      from "TODO"       [2024-01-15 Mon 11:06]
:END:
If ECSQL is implemented with heavy use of macros, a relatively small
amount of additional work would be necessary to also implement more
languages that may work with ECS.  Our ideas are as follows:
**** Story/Dialog System
Conversation trees could be implemented quite naturally as a Lisp DSL,
containing arbitrary calls to Lisp code for conditions like "has
the player got the macguffin?".
**** Text Markup
Allow arbitrary tree structure for pieces of text, with basic bold and
italic markup.  E.g:
#+begin_src lisp-data
("This is something I" (_ "have") "to see.")
(if (has player macguffin)
    "My macguffin! Please return it."
  "I need someone to find my macguffin...")
#+end_src
This snippet includes a check using the ~has~ predicate, which could
be generated by ECSQL based on a relationship with the same name.
**** Scene Tree
Inspired by Flecs, it would be convenient to represent the entire
state of a game as list structure, especially for (de-)serialisation.
*** TODO Lisp Compiler Target
Options:
**** LLVM IR
| Advantages   | Disadvantages                     |
|--------------+-----------------------------------|
| Native speed | Complex C++ API, incomplete C API |
| Intrinsics   | A large, heavy dependency         |
| Familiarity  | Not for the C API                 |
**** Own bytecode
| Advantages         | Disadvantages               |
|--------------------+-----------------------------|
| Fewer dependencies | Slower                      |
|                    | Lots of irrelevant problems |
**** LibGCCJIT
| Advantages                    | Disadvantages         |
|-------------------------------+-----------------------|
| Ganoooo!1!                    | Unfamiliar            |
| Very simple(?)                |                       |
| Similar to LLVM               | Limited documentation |
| C is primary API              |                       |
| Primarily intended for JIT(?) |                       |

*** TODO Compiler Architecture
1. Reader (lex + parse): Output is already Lisp data!
2. Lisp → Stack Machine:
   #+begin_src lisp-data
     (label
      (push 5)
      (push 4)
      (call + )
      (return))
   #+end_src
   - As in Queinnec.  Probably the most complex part, and it can be
     totally backend-independent!
   - Stack machine has a limited, but non-trivial instruction set that
     should easily map to libgccjit or LLVM IR, notably including
     (variadic) function calls.
   - CFG form(?)
   - Maximum stack depth in each function is known statically (deepest
     expression nesting level).
3. Evaluator: libgccjit or simple interpreter.
** Implementation
*** TODO Lisp [2/10]
**** DONE Lexer
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-11 Thu 18:11] \\
  - Decided against active UTF-8 support, but it would probably work.
  - Treat ~@~ as a stand-alone Token. The parser can easily "look ahead"
    when it gets a ~,~ to see if it should be a normal or splicing
    unquote.
CLOCK: [2024-01-11 Thu 18:04]--[2024-01-11 Thu 18:11] =>  0:07
CLOCK: [2024-01-11 Thu 14:50]--[2024-01-11 Thu 18:04] =>  3:14
- State "DOING"      from "TODO"       [2024-01-11 Thu 14:49]
:END:
- [X] Token type
- [ ] +UTF-8+
This either needs to operate on a string buffer in memory, or a
~FILE*~.  There are platform-dependent ways to access a string buffer
as a ~FILE*~, and many platform-independent operators for ~FILE*~'s,
so we will use ~FILE*~.
**** DONE Lisp Object Physical Representation
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-15 Mon 10:26] \\
  We found a reasonable compromise representation.
CLOCK: [2024-01-12 Fri 15:11]--[2024-01-12 Fri 19:26] =>  4:15
CLOCK: [2024-01-11 Thu 18:19]--[2024-01-11 Thu 18:22] =>  0:03
- State "DOING"      from "TODO"       [2024-01-11 Thu 18:18]
:END:
- For this, consider 64-bit integer boxing.
- Notable: There are 12 unused bits in Mertens's Entity
  representation, and we can probably shave off a few bits from the
  generation and Entity, so this could fit inside a NaN box!
- Queinnec: p. 391, tinylisp: p. 7-9

I need a representation for Lisp objects that is simple enough to
manipulate inline with generated LLIR, and reasonably efficient.

***** Constraints/Requirements
- Must represent the following:
  - Standard Lisp types:
  - Vectors (ideally):
  - Entity IDs and relations (require c. 50b):
  - User-defined structs: Pointer to storage, getters, setters;
    Use the ~getelementptr~ LLIR instruction.
  - Archetypes:
  The question is how many of these must be hard-coded into the object
  representation.  If a fundamental structure like Entity IDs can fit
  into an object inline, that allows some decent optimisation of how
  generated code can handle them.
- 64 bits: Biggest easily moveable size.
***** NaN Boxing
- tinylisp/van Engelen
- 51 bits for non-float values
***** Pointer/Int Boxing
- Queinnec, p. 390.
- LSB 1 → integer in upper 63 bits
- LSB 0 → pointer to object union.
- The pointer value is aligned, since the pointee is a large object,
  so 2+ LSBs are 0. The rest of the LSBs can store type info.
- Pointers can be used as-is, but getting the type for non-integers
  requires a separate memory read.  Given the cost of memory access is
  orders of magnitude greater than individual instructions, we should
  include all such metadata in the immediate value, even if it is more
  work to extract.
***** Considerations for my version
- If we need even fewer than 63 bits, we can store more than just
  integers inline.
- If addresses are indices into the Lisp memory pool (useful for
  relocation, etc.), 32- or maybe 48-bit integers would be sufficient,
  and we don't rely on pointer alignment, so the exact position of the
  bits is of less concern.
- The type recognition scheme needs to be simple and non-branching,
  since it will need to run almost continuously.
- 5 bits for Lisp type tag, to ensure we don't run out.
- Definition: An immediate value contains its data, as opposed to an
  indirect value.  The NaN-boxed address in Lisp memory is the
  representation for indirect values.

Discussion: Do the Entity ID types need to be explicitly in the types?
- If they are immediate, Lisp code can manipulate their contents
  highly efficiently.
- This could be achieved equally well by storing them in the integer
  type, right?
- Making them first-class was a primary justification for me building
  my own Lisp at all.
- With them built-in, we gain some protection from user input, since
  they can't so easily supply a garbage integer value: Entity IDs can
  only be generated by the system itself.
- Cost of "blessing" them: Complexity?
- Poor unity of purpose having 5 possible immediate meanings?
***** NaN-Boxed
#+begin_example
+-------------------------------+-----------------------------++
<-------------------- Double  (62b)----------------------------> Value is a valid double as-is!
s111111111111<--------Arbitrary Data Goes Here (46b)------><typ> QNaN boxed. Type
s111111111111<-------Entity (27b)------><---Gen (16b)--><-><typ> Type Flags (c. 3b)
s111111111111<--Comp/Rel T ------(27b)-><-- Rel  (16b)-><-><typ>

Undesirable:
<---------------Integer (63b)--------------------------------->1
#+end_example
***** Non-NaN-Boxed
NaN-boxing incurs an excessive overhead, which especially hurts the
Entity ID representation due to Mertens, which is already squeezed
tightly into 64 bits, especially for relation pairs.  A 5-bit Lisp
object type tag should be sufficient to represent all fundamental
types in the language, while leaving plenty of space for immediate
values.
#+begin_example
+-------------------------------+-----------------------------++
<----------------------Data (59b)-------------------------><typ>
<-------Entity (32b)-----------><---Gen (16b)-->0000000<*-><typ> *Entity type flags (4b)
<--Comp/Rel T ------(32b)------><---Relation (23b)----><--><typ>
<----------------------Integer (59b)----------------------><typ>
<----------------------"Double" (64b)---------------------><typ>
<-----------Pointer (43b)-----------------><-Metadata(16b)><typ>
#+end_example
Our double type is handled specially: the 5 type bits align with the
LSBs of a double's mantissa.  To get the represented value, we will
mask out the type bits instead of shifting.  This allows us to
represent the full range of doubles, with only a moderate loss of
precision.

We only have 23 bits for Entity relationships, but this still allows
8,388,608 different relationships to be represented, which should be
plenty.

A lot of object values will contain a "pointer" to Lisp data (more
likely an index), which may need to be accompanied by some metadata.
The pointer size places an upper bound on how large Lisp memory can be
(including the overhead of uncollected garbage), so we allocate an
excessive 43 bits to it.  The metadata will often be the length of a
slice type (e.g. for arrays), which may not necessarily be in units of
Lisp cells (e.g. for strings).

Pointer+length objects are called fat pointers, and provide numerous
benefits such as creating slices of arrays without having to move the
data.

Strings and symbols should probably be handled differently to keep
things efficient.

The bare essential built-in types are:
- [ ] Integer
- [ ] Double
- [ ] String
- [ ] Lisp machinery types (e.g. closure, symbol, cons cell)
- [ ] Fixed-length vectors(?)
- [ ] Struct
**** TODO Scope and Namespaces
- Lexical
- Lisp-1
**** TODO Memory Allocation
- Copying GC.
- Allocate in increments of 64-bit cells?
- The /directly referenced/ values of global variables can be placed
  in a "static" data store, though this is a small optimisation.
**** TODO Pure C Parser
- [ ] List structure
- [ ] Literals
- [ ] ~'~, ~`~, ~,~, ~,@~.
**** TODO [#C] Parser with Macros
Macros are a productivity multiplier that may prove necessary in order
to complete the project on time.
***** TODO [#B] Backquote
- This feature is essential for the ergonomics of a macro system.
- If not implemented "properly" as a reader macro, it would be easy
  enough to hard-code it into a pure C reader.
***** TODO [#C] Read Macros
**** TODO Code Generation
**** TODO [#C] Optimisations
- Just turn on the feature in LLVM?
**** TODO REPL
Basically necessary to the way Lisp should function, including macros.
**** TODO Error Handling
Probably just halt with a message/trace, or whatever is built into
LLVM?
*** TODO ECS [0/4]
**** TODO Component Store
**** TODO Entity IDs
**** TODO Systems
**** TODO [#C] Relationships
- Is this essential?
- What is the simplest form of relationships I could implement?
***** Mertens' Roadmap, Culled
https://ajmmertens.medium.com/a-roadmap-to-entity-relationships-5b1d11ebb4eb

Mertens describes the first 5 steps as sufficient to produce a
rudimentary implementation of relationships, with an estimated time to
implement of 16 weeks.
1. [X] Components as entities
2. [ ] Observers
3. [X] Relationship pairs in archetype storage
4. [ ] Relationship components: Flecs makes this highly complex with a
   sequence of rules that are tried.  We can probably find a "worse"
   compromise set of rules, or exclude this feature altogether.
   Example compromise rules:
   1. Never create storage for the first element.
   2. Create the storage for the second element iff it's a non-tag
      type:
      - ~e.add(apples, eats, {2})~
      - ~e.add(parent, childOf)~
   Or:
   1. Include a tag bit in the pair representation.
   2. Associate with type of first element, iff tag bit is 0.
   This might not work, since that tag bit isn't representable
   in the Query DSL syntax:
   - ~(child-of parent)~,
   - ~((eats 2) apples)~
   In any case, we can simply add any data we want to one of the
   entities in the relationship.
5. [X] Wildcard queries: Looks impressive, and Mertens doesn't even
   consider it especially hard, at "merely" 2 weeks.
6. [ ] Component index
7. [ ] Cleanup: Important, but we must find a simplified approach if
   we are to consider implementing it.
8. [ ] Cleanup Traits
9. [ ] Multi-source queries
10. [ ] Relationship traversal
11. [ ] Query cache revalidation
12. [ ] Breadth first traversal
13. [ ] Uncached queries
14. [ ] Multi component observers
15. [ ] Event propagation
16. [ ] Empty table optimisation
17. [ ] Garbage collection
18. [ ] Rule engine
19. [ ] Exclusive relationships
20. [ ] Inheritance
21. [ ] Query DSL
***** My Approach
- For starters, relationship components seem like a mostly unnecessary
  feature.
- How much could we hand off to a working Lisp implementation?
  - Notably, garbage collection?!
