#+title: ECSQL
#+author: Aidan Hall
#+todo: TODO DOING(!) | DONE(@) CANCELLED(@)
* Introduction
This is the source code for ECSQL.
#+begin_src emacs-lisp
(inferior-lisp (file-truename "./ecsql"))
#+end_src
* Tasks
:PROPERTIES:
:COLUMNS:  %ITEM %PRIORITY %TODO
:END:
`Since we must rely on some piece of software for project management,
we will use the most reliable one (in terms of longevity): Emacs.
** Design
*** TODO Basic ECS Architecture [0/3]
**** TODO Automatically generated Entity IDs
**** TODO Component Store
**** TODO System Scheduler
*** TODO ECSQL Language Specification [0/11]
- [ ] Create and delete entities
- [ ] Add and remove Components
- [ ] Display and edit Component data
- [ ] Entity/Component selection with Queries, based on the Entity relationships in the ECS design.
- [ ] Start and stop systems
- [ ] List running systems
- [ ] Component data transformation, via calls to Systems and functions
- [ ] System composition, and definition of new systems based on these compositions
- [ ] FFI to Systems written in host language
- [ ] Deferred event queue
- [ ] BNF grammar
*** DOING Many Languages
:LOGBOOK:
- State "DOING"      from "TODO"       [2024-01-15 Mon 11:06]
:END:
If ECSQL is implemented with heavy use of macros, a relatively small
amount of additional work would be necessary to also implement more
languages that may work with ECS.  Our ideas are as follows:
**** Story/Dialog System
Conversation trees could be implemented quite naturally as a Lisp DSL,
containing arbitrary calls to Lisp code for conditions like "has
the player got the macguffin?".
**** Text Markup
Allow arbitrary tree structure for pieces of text, with basic bold and
italic markup.  E.g:
#+begin_src lisp-data
("This is something I" (_ "have") "to see.")
(say npc-jeff
 (if (has player macguffin)
     "My macguffin! Please return it."
   "I need someone to find my macguffin..."))
#+end_src
This snippet includes a check using the ~has~ predicate, which could
be generated by ECSQL based on a relationship with the same name.
**** Scene Tree
Inspired by Flecs, it would be convenient to represent the entire
state of a game as list structure, especially for (de-)serialisation.
**** Graph/Data Flow Language
On [[https://ajmmertens.medium.com/ecs-from-tool-to-paradigm-350587cdf216][Mertens' wish list]]; probably easy to represent a graph structure as
Lisp data, could help to justify extreme slowness, quite novel.
*** DONE Lisp Compiler Target
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-26 Fri 15:36] \\
  Just do the naive interpreter, unless we are /done/ done, with
  everything else, very early.
- State "DOING"      from "TODO"       [2024-01-26 Fri 15:36]
:END:
Options:
**** Naive Interpreter
Potentially useful for testing and bootstrapping purposes.
**** LLVM IR
| Advantages   | Disadvantages                     |
|--------------+-----------------------------------|
| Native speed | Complex C++ API, incomplete C API |
| Intrinsics   | A large, heavy dependency         |
| Familiarity  | Not for the C API                 |
| Phi nodes    |                                   |
**** Own bytecode
| Advantages         | Disadvantages               |
|--------------------+-----------------------------|
| Fewer dependencies | Slower                      |
|                    | Lots of irrelevant problems |
**** LibGCCJIT
| Advantages                    | Disadvantages         |
|-------------------------------+-----------------------|
| Ganoooo!1!                    | Unfamiliar            |
| Very simple(?)                | No Phi nodes          |
| Similar to LLVM               | Limited documentation |
| C is primary API              |                       |
| Primarily intended for JIT(?) |                       |
The lack of Phi nodes is notable because they fuse the results of
branches /in an expression/.  We may be able to hack them on top of
the conditional and switch instructions.
*** DONE Compiler Architecture
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-26 Fri 15:36] \\
  Evaluator.  See [[*Lisp Compiler Target]].
- State "DOING"      from "TODO"       [2024-01-26 Fri 15:36]
:END:
1. Reader (lex + parse): Output is already Lisp data!
2. Lisp → Stack Machine:
   #+begin_src lisp-data
     (label
      (push 5)
      (push 4)
      (call + )
      (return))
   #+end_src
   - As in Queinnec.  Probably the most complex part, and it can be
     totally backend-independent!
   - Stack machine has a limited, but non-trivial instruction set that
     should easily map to libgccjit or LLVM IR, notably including
     (variadic) function calls.
   - CFG form(?)
   - Maximum stack depth in each function is known statically (deepest
     expression nesting level).
3. Evaluator: libgccjit or simple interpreter.
** Implementation
*** DONE Lisp Interpreter [14/14]
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-02-05 Mon 11:04] \\
  We have now implemented a sufficient interpreter to do some
  higher-level ECS stuff with macros, though that depends on having the
  ECS itself, so the primary Lisp implementation is done.
- State "DOING"      from "TODO"       [2024-02-05 Mon 11:04]
:END:
**** DONE Lexer
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-11 Thu 18:11] \\
  - Decided against active UTF-8 support, but it would probably work.
  - Treat ~@~ as a stand-alone Token. The parser can easily "look ahead"
    when it gets a ~,~ to see if it should be a normal or splicing
    unquote.
CLOCK: [2024-01-11 Thu 18:04]--[2024-01-11 Thu 18:11] =>  0:07
CLOCK: [2024-01-11 Thu 14:50]--[2024-01-11 Thu 18:04] =>  3:14
- State "DOING"      from "TODO"       [2024-01-11 Thu 14:49]
:END:
- [X] Token type
- [ ] +UTF-8+
This either needs to operate on a string buffer in memory, or a
~FILE*~.  There are platform-dependent ways to access a string buffer
as a ~FILE*~, and many platform-independent operators for ~FILE*~'s,
so we will use ~FILE*~.
**** DONE Lisp Object Physical Representation
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-15 Mon 10:26] \\
  We found a reasonable compromise representation.
CLOCK: [2024-01-12 Fri 15:11]--[2024-01-12 Fri 19:26] =>  4:15
CLOCK: [2024-01-11 Thu 18:19]--[2024-01-11 Thu 18:22] =>  0:03
- State "DOING"      from "TODO"       [2024-01-11 Thu 18:18]
:END:
- For this, consider 64-bit integer boxing.
- Notable: There are 12 unused bits in Mertens's Entity
  representation, and we can probably shave off a few bits from the
  generation and Entity, so this could fit inside a NaN box!
- Queinnec: p. 391, tinylisp: p. 7-9

I need a representation for Lisp objects that is simple enough to
manipulate inline with generated LLIR, and reasonably efficient.

***** Constraints/Requirements
- Must represent the following:
  - Standard Lisp types:
  - Vectors (ideally):
  - Entity IDs and relations (require c. 50b):
  - User-defined structs: Pointer to storage, getters, setters;
    Use the ~getelementptr~ LLIR instruction.
  - Archetypes:
  The question is how many of these must be hard-coded into the object
  representation.  If a fundamental structure like Entity IDs can fit
  into an object inline, that allows some decent optimisation of how
  generated code can handle them.
- 64 bits: Biggest easily moveable size.
***** NaN Boxing
- tinylisp/van Engelen
- 51 bits for non-float values
***** Pointer/Int Boxing
- Queinnec, p. 390.
- LSB 1 → integer in upper 63 bits
- LSB 0 → pointer to object union.
- The pointer value is aligned, since the pointee is a large object,
  so 2+ LSBs are 0. The rest of the LSBs can store type info.
- Pointers can be used as-is, but getting the type for non-integers
  requires a separate memory read.  Given the cost of memory access is
  orders of magnitude greater than individual instructions, we should
  include all such metadata in the immediate value, even if it is more
  work to extract.
***** Considerations for my version
- If we need even fewer than 63 bits, we can store more than just
  integers inline.
- If addresses are indices into the Lisp memory pool (useful for
  relocation, etc.), 32- or maybe 48-bit integers would be sufficient,
  and we don't rely on pointer alignment, so the exact position of the
  bits is of less concern.
- The type recognition scheme needs to be simple and non-branching,
  since it will need to run almost continuously.
- 5 bits for Lisp type tag, to ensure we don't run out.
- Definition: An immediate value contains its data, as opposed to an
  indirect value.  The NaN-boxed address in Lisp memory is the
  representation for indirect values.

Discussion: Do the Entity ID types need to be explicitly in the types?
- If they are immediate, Lisp code can manipulate their contents
  highly efficiently.
- This could be achieved equally well by storing them in the integer
  type, right?
- Making them first-class was a primary justification for me building
  my own Lisp at all.
- With them built-in, we gain some protection from user input, since
  they can't so easily supply a garbage integer value: Entity IDs can
  only be generated by the system itself.
- Cost of "blessing" them: Complexity?
- Poor unity of purpose having 5 possible immediate meanings?
***** NaN-Boxed
#+begin_example
+-------------------------------+-----------------------------++
<-------------------- Double  (62b)----------------------------> Value is a valid double as-is!
s111111111111<--------Arbitrary Data Goes Here (46b)------><typ> QNaN boxed. Type
s111111111111<-------Entity (27b)------><---Gen (16b)--><-><typ> Type Flags (c. 3b)
s111111111111<--Comp/Rel T ------(27b)-><-- Rel  (16b)-><-><typ>

Undesirable:
<---------------Integer (63b)--------------------------------->1
#+end_example
***** Non-NaN-Boxed
NaN-boxing incurs an excessive overhead, which especially hurts the
Entity ID representation due to Mertens, which is already squeezed
tightly into 64 bits, especially for relation pairs.  A 5-bit Lisp
object type tag should be sufficient to represent all fundamental
types in the language, while leaving plenty of space for immediate
values.
#+begin_example
+-------------------------------+-----------------------------++
<----------------------Data (59b)-------------------------><typ>
<-------Entity (32b)-----------><---Gen (16b)-->0000000<*-><typ> *Entity type flags (4b)
<--Comp/Rel T ------(32b)------><---Relation (23b)----><--><typ>
<----------------------Integer (59b)----------------------><typ>
<----------------------"Double" (64b)---------------------><typ>
<-----------Index   (43b)-----------------><-Metadata(16b)><typ>
#+end_example
Our double type could be handled specially: the 5 type bits align with
the LSBs of a double's mantissa.  To get the represented value, we
will mask out the type bits instead of shifting.  This allows us to
represent the full range of doubles, with only a moderate loss of
precision.  In reality, it will be easier to just box a 32-bit float
normally, since these are the standard in games anyway.

We only have 23 bits for Entity relationships, but this still allows
8,388,608 different relationships to be represented, which should be
plenty.

A lot of object values will contain a "pointer" to Lisp data (more
likely an index), which may need to be accompanied by some metadata.
The pointer size places an upper bound on how large Lisp memory can be
(including the overhead of uncollected garbage), so we allocate an
excessive 43 bits to it.  The metadata will often be the length of a
slice type (e.g. for arrays), which may not necessarily be in units of
Lisp cells (e.g. for strings).

Pointer+length objects are called fat pointers, and provide numerous
benefits such as creating slices of arrays without having to move the
data.

Strings and symbols should probably be handled differently to keep
things efficient.

The bare essential built-in types are:
- [X] Integer
- [X] Double
- [X] String
- [X] Symbol
- [X] Pair
- [X] Primitive function
- [X] Closure (lambda)
- [ ] Compiled Closure(?)
- [X] Fixed-length vectors(?)
- [ ] Struct

**** DONE Scope, Namespaces etc.
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-26 Fri 12:13] \\
  - We have created a trivial implementation of Lisp-3 (variables,
    functions, macros), with lexical scope for variables and only global
    scope for functions and macros.
  - Macros are implemented simply as closures.
- State "DOING"      from "TODO"       [2024-01-22 Mon 10:31]
:END:
- Lexical
- Lisp-1?
  - Lisp-1 is more conceptually elegant, but Lisp-2 may be easier/more
    efficient to compile.
- There's a question of how to implement scopes.  If they aren't
  needed at run-time, it may be acceptable to use a naive alist
  structure.
- Conceptually pure approach: Only implement local/lexical binding
  through lambda parameter lists, though this requires either Lisp-1
  or the "special case" first-position ~lambda~ of Common Lisp.
- Variable-length argument lists are a similar consideration: An
  actual Lisp list in the "AST" can easily be converted to a
  variable-length argument pack in libgccjit.  On the other hand, in
  real Lisps, variable argument lists are treated as actual lists by
  the callee too, so the obvious solution /may/ be sufficient.
  - Solution: Put /all/ the arguments into a list, and for
    variable-length argument lists, make the "rest" parameter the
    ~cdr~ past a certain point.
**** DONE Memory Allocation
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-22 Mon 10:31] \\
  Garbage collection is actually quite low-priority, so we can defer it
  until we know we have time for it.
- State "DOING"      from "TODO"       [2024-01-22 Mon 10:31]
:END:
- Allocate in increments of 64-bit cells?
- The /directly referenced/ values of global variables can be placed
  in a "static" data store, though this is a small optimisation.
**** CANCELLED Copying GC
:LOGBOOK:
- State "CANCELLED"  from "TODO"       [2024-01-26 Fri 15:37] \\
  Leaking into a 1GB+ buffer is fine, since GC isn't relevant to the
  project concept.
:END:

**** DONE Pure C Parser
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-22 Mon 10:35] \\
  Actually implemented reader macro support with function pointers.  It
  should be possible to write new ones as compiled functions.
- State "DOING"      from "TODO"       [2024-01-22 Mon 10:34]
:END:
- [X] List structure
- [X] Literals
- [X] ~'~, ~`~, ~,~, ~?~
- [ ] ~,@~: Requires more context, and quite niche: won't do.
**** DONE [#C] Parser with Macros
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-22 Mon 10:37] \\
  See [[*Pure C Parser]].
- State "DOING"      from "TODO"       [2024-01-22 Mon 10:37]
:END:
Macros are a productivity multiplier that may prove necessary in order
to complete the project on time.
**** CANCELLED [#B] Splicing Unquote
:LOGBOOK:
- State "CANCELLED"  from "TODO"       [2024-01-26 Fri 12:10] \\
  We can use the dot operator to get most of the benefit of this with no
  extra work:
  - ~`(some things are so . ,(or 'cool 'lame))~
  - ~(some things are so cool)~
:END:
- This feature is essential for the ergonomics of a macro system.
- If not implemented "properly" as a reader macro, it would be easy
  enough to hard-code it into a pure C reader.
***** DONE [#C] Read Macros
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-22 Mon 10:38] \\
  See [[*Pure C Parser]].
- State "DOING"      from "TODO"       [2024-01-22 Mon 10:38]
:END:
**** CANCELLED Code Generation
:LOGBOOK:
- State "CANCELLED"  from "TODO"       [2024-01-26 Fri 15:38] \\
  Not doing a compiler.
:END:

**** CANCELLED [#C] Optimisations
:LOGBOOK:
- State "CANCELLED"  from "TODO"       [2024-01-26 Fri 15:38] \\
  We don't care about performance.
:END:
- Just turn on the feature in the code generator.
**** DONE REPL
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-26 Fri 12:06] \\
  Could be implemented in Lisp instead of C, but this periodic movement
  of control back out of Lisp is a good opportunity to perform garbage
  collection since the Lisp stack is empty at that point, so we only
  need to use global variables as roots.
- State "DOING"      from "TODO"       [2024-01-22 Mon 10:32]
:END:
Basically necessary to the way Lisp should function, including macros.
- [X] Read
- [X] Eval
- [X] Print: This will need extension every time we add a fundamental
  type, but
- [X] Loop
**** DONE Error Handling
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-01-26 Fri 12:05] \\
  Simplistic error message + longjmp is quite sufficient.
- State "DOING"      from "TODO"       [2024-01-22 Mon 10:59]
:END:
Ideally this should be entirely handled by the ~wrong~ function.
Options:
#+attr_org: :radio t
- [ ] Invalid type/error object (de facto approach)
- [X] setjmp/longjump
**** CANCELLED [#C] LValues
:LOGBOOK:
- State "CANCELLED"  from "TODO"       [2024-02-05 Mon 11:02] \\
  This would introduce a very un-Lispy complication to the
  implementation.
:END:
- ~(setf place value)~: ~place~ must be an lvalue.
- In C/libgccjit, lvalues are a subkind of rvalues (normal values).
- Issues:
  - Can't have references to globals, outside Lisp memory.
  - Potential efficiency cost, especially for struct accessors.
**** DONE Struct Types
:LOGBOOK:
- State "DONE"       from "DOING"      [2024-02-05 Mon 11:02] \\
  Implemented in Lisp as far as possible (only using C to manipulate
  internal representations), with simple 1-cell alignment/size for all
  primitive types.
- State "DOING"      from "TODO"       [2024-02-05 Mon 11:02]
:END:
- Use libgccjit's structs for reflection etc.
Requirements:
- [ ] Getters
- [ ] *Setters*: Do we attempt "generalised variables"?
- [ ] Field types: All fundamental types, or struct types(?).
Lisp Representation:
- Storage :: Vector, each member (which *must* be of the provided
  typespec, checked by ~lisp_type_spec_matches~) in a cell.
- Name :: Symbol, bound in the function namespace as a constructor(?).
- Definition :: As below:
  #+begin_src lisp
(defstruct v3f
  (x f32)
  (y f32)
  (z f32))
(defstruct physics
  (pos v3f) ; Recursive structs
  (vel v3f))
(defstruct node
  (car t)
  (cdr t))
  #+end_src
- API :: As below:
  #+begin_src lisp
(node-car (make-node 'a 'b)) ; a
(set-v3f-x v (+ 1 (v3f-x v)))
(set-physics-pos-x player (+ 1 (physics-pos-x player)))
(set-physics-vel player (make-vector 2 2 2))
  #+end_src
- Single Inheritance :: Possibly useful idea: Same members and
  interface as another struct, but considered a distinct type by Lisp.
  - Could be as simple as physically splicing in the struct member
    list from the parent class and dispatching to normal ~defstruct~.
  - Include a cast to the base class.
  - Not in the spirit of, or relevant to, what we are doing.
*** TODO ECS [0/5]
**** TODO Entity IDs
**** TODO Component Store
**** TODO Systems
**** TODO [#C] Relationships
- Is this essential?
- What is the simplest form of relationships I could implement?
***** Mertens' Roadmap, Culled
https://ajmmertens.medium.com/a-roadmap-to-entity-relationships-5b1d11ebb4eb

Mertens describes the first 5 steps as sufficient to produce a
rudimentary implementation of relationships, with an estimated time to
implement of 16 weeks.
1. [X] Components as entities
2. [ ] Observers
3. [X] Relationship pairs in archetype storage
4. [ ] Relationship components: Flecs makes this highly complex with a
   sequence of rules that are tried.  We can probably find a "worse"
   compromise set of rules, or exclude this feature altogether.
   Example compromise rules:
   1. Never create storage for the first element.
   2. Create the storage for the second element iff it's a non-tag
      type:
      - ~e.add(apples, eats, {2})~
      - ~e.add(parent, childOf)~
   Or:
   1. Include a tag bit in the pair representation.
   2. Associate with type of first element, iff tag bit is 0.
   This might not work, since that tag bit isn't representable
   in the Query DSL syntax:
   - ~(child-of parent)~,
   - ~((eats 2) apples)~
   In any case, we can simply add any data we want to one of the
   entities in the relationship.
5. [X] Wildcard queries: Looks impressive, and Mertens doesn't even
   consider it especially hard, at "merely" 2 weeks.
6. [ ] Component index
7. [ ] Cleanup: Important, but we must find a simplified approach if
   we are to consider implementing it.
8. [ ] Cleanup Traits
9. [ ] Multi-source queries
10. [ ] Relationship traversal
11. [ ] Query cache revalidation
12. [ ] Breadth first traversal
13. [ ] Uncached queries
14. [ ] Multi component observers
15. [ ] Event propagation
16. [ ] Empty table optimisation
17. [ ] Garbage collection
18. [ ] Rule engine
19. [ ] Exclusive relationships
20. [ ] Inheritance
21. [ ] Query DSL
***** My Approach
- For starters, relationship components seem like a mostly unnecessary
  feature.
- How much could we hand off to a working Lisp implementation?
  - Notably, garbage collection?!
**** TODO [#A] Lisp API
- We should provide a flexible API, so new features/applications can
  be built entirely in Lisp.
- Is a Lisp callback API ("for each Entity") sensible? Does a
  facsimile crafted with macros make more sense?
- Need to find a good way to make it terse: Lisp code interfacing with
  strong types can quickly become annoying to read and write:
  - Bad:
    ~(set-x (get-vec (get-velocity entity)) 3)~
  - Better:
    ~(setf (x (velocity entity)) 3)~
  - Better still:
    ~(setf (x velocity) 3)~, with velocity bound as an "lvalue" with
    macro/codegen sorcery.
  - ~(setf velocity [3 0 0])~
- Trying to produce a nice API like one would have in C may be the
  wrong approach: Allow the C plumbing API to be awful, and build nice
  ones on top of that?
