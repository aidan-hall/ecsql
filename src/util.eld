(defun consp (v)
  (eq (type-of v) 'pair))
(defun not (v)
  (eq v nil))
(defun listp (v)
  (or (consp v) (not v)))
(defun type-spec-matches (value spec)
  (or (eq spec t)
      (and (consp value) (consp spec)
           (type-spec-matches (car value) (car spec))
           (type-spec-matches (cdr value) (cdr spec)))
      (and (not value) (not spec))
      (eq (type-of value) spec)))
(defun mapcar (f l)
  (if (not l)
      nil
    (cons (funcall f (car l))
          (mapcar f (cdr l)))))

(defmacro let (binds . body)
  ((lambda (names values)
     `((lambda ,names
         . ,body)
       . ,values))
   (mapcar (function car) binds)
   (mapcar (lambda (bind) (car (cdr bind))) binds)))

(defmacro let* (binds . body)
  (if binds
      `(let (,(car binds))
         (let* ,(cdr binds) . ,body))
    `(progn ,body)))

(defun equal (a b)
  (if (and (consp a) (consp b))
      (and (equal (car a) (car b))
           (equal (cdr a) (cdr b)))
    (eql a b)))
